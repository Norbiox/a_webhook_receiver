# Other Details and Decisions

Pending questions to answer before implementation.

---

## API Design

1. What is the URL for submitting a webhook? `POST /webhooks` or something else? 
  `POST /webhooks`
2. What is the URL for checking event status — by internal ID (`GET /webhooks/{id}`) or by idempotency key (`GET /webhooks?idempotency_key=evt-001`), or both?
  both
3. What fields should the POST response include? (e.g. `id`, `status`, `created_at`)
  `id`, `idempotency_key`, `status`, `created_at`
4. What fields should the status response include? (e.g. `id`, `idempotency_key`, `status`, `attempts`, `created_at`, `updated_at`)
  `id`, `idempotency_key`, `status`,  `created_at`, `updated_at`
5. What HTTP status code should a new webhook return — `200 OK` or `202 Accepted`?
  `202 Accepted`
6. What HTTP status code should a duplicate webhook return — `200 OK`, `202 Accepted`, or `409 Conflict`?
  `200 OK` (Stripe does that)
7. Should the response body differ between a new event and a duplicate, or return the same shape?
  same shape

---

## Observability

8. Should logs be structured (JSON) or plain text?
  plain text, it's a prototype. In production I would use OpenTelemetry
9. Should each webhook be assigned a correlation/trace ID for log tracing? If yes, generated by the service or taken from a request header (e.g. `X-Request-ID`)?
  not in prototype, but useful in production
10. What log levels should be used for key events — ingestion, duplicate detected, processing start, processing complete, retry scheduled, failure?
  info, info, info, info, info, error
11. Should a `/health` endpoint be implemented (liveness)?
  yes
12. Should a `/ready` endpoint be implemented (readiness — i.e. not ready until startup queue load is complete)?
  yes, not ready until startup queue load is complete
13. Should Prometheus metrics be exposed? If yes, which ones — queue depth, processing latency, ingestion rate, error rate?
  yes, all

---

## Rate Limiting

14. Should rate limiting be implemented in the prototype at all, or documented as a TODO?
  documented as a TODO
16. Should rate limiting be handled in-app (e.g. `slowapi`) or delegated to a reverse proxy (nginx, Traefik)?
  reverse proxy

---

## Deployment

17. What base Docker image should be used — `python:3.x-slim`, `python:3.x-alpine`, or other?
  `python:3.14-alpine`
18. Where should the SQLite file be stored in the container — hardcoded path or configurable via env var (`DB_PATH`)?
  configurable via env var (`DB_PATH`), defualt `/data/events.db`, `/data` is volume mount
19. Should the Dockerfile use a non-root user?
  yes, create user `appuser`
20. Should the container expose a configurable port via env var, or hardcode it (e.g. `8000`)?
  hardcode it to 8000

--

## Technical requirements

21. Use python 3.14 with FastAPI
22. Incremental implementation in TDD approach, use pytest for testing
23. Ruff for formatting and linting
24. Type annotations everywhere
25. No need to overengineer, keep it simple yet elegant (no functions longer than 15 lines, DRY, KISS, SOLID etc.)
